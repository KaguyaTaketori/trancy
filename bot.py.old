"""
Telegram Translation Userbot â€” see docstring at top for setup.
"""

import asyncio
import json
import logging
import os
import re
import sys
import time
from typing import Any

from dotenv import load_dotenv
from deep_translator import GoogleTranslator
from google import genai
from langdetect import detect as langdetect_detect, LangDetectException
from openai import AsyncOpenAI
from pyrogram import Client, filters
from pyrogram.enums import ParseMode

# â”€â”€ Logging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
)
logger = logging.getLogger("translate_bot")

# â”€â”€ Python 3.12+ compat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
try:
    asyncio.get_running_loop()
except RuntimeError:
    if sys.platform == "win32":
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    asyncio.set_event_loop(asyncio.new_event_loop())

# â”€â”€ Credentials â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
load_dotenv()
try:
    API_ID: int = int(os.environ["API_ID"])
    API_HASH: str = os.environ["API_HASH"]
except KeyError as missing:
    logger.critical("Missing required env variable: %s  ->  add it to .env", missing)
    sys.exit(1)

FALLBACK_OPENAI_KEY: str = os.getenv("FALLBACK_OPENAI_KEY", "")
FALLBACK_GEMINI_KEY: str = os.getenv("FALLBACK_GEMINI_KEY", "")
CONFIG_FILE = "config.json"

DEFAULT_CONFIG: dict[str, Any] = {
    "default_lang": "ja",
    "home_lang": "zh-CN",
    "engine": "gemini",
    "custom_engines": {},
    "models": {"openai": "gpt-4o-mini", "gemini": "gemini-1.5-flash"},
    "auto_cmd": "",
    "api_keys": {"openai": "", "gemini": ""},
}

# â”€â”€ Config cache â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_config_cache: dict[str, Any] | None = None

def load_config() -> dict[str, Any]:
    global _config_cache
    if _config_cache is not None:
        return _config_cache
    config = {k: v for k, v in DEFAULT_CONFIG.items()}
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, "r", encoding="utf-8") as f:
                saved = json.load(f)
            config.update(saved)
        except (json.JSONDecodeError, OSError) as e:
            logger.warning("Could not load config, using defaults: %s", e)
    _config_cache = config
    return _config_cache

def save_config(key: str, value: Any) -> None:
    global _config_cache
    config = load_config()
    config[key] = value
    _config_cache = config
    try:
        with open(CONFIG_FILE, "w", encoding="utf-8") as f:
            json.dump(config, f, ensure_ascii=False, indent=2)
    except OSError as e:
        logger.error("Failed to save config: %s", e)

# â”€â”€ API clients (cached per key) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_openai_clients: dict[str, AsyncOpenAI] = {}
_gemini_clients: dict[str, genai.Client] = {}

def get_openai_client(config: dict[str, Any]) -> AsyncOpenAI:
    key = config["api_keys"].get("openai") or FALLBACK_OPENAI_KEY
    if key not in _openai_clients:
        _openai_clients[key] = AsyncOpenAI(api_key=key)
    return _openai_clients[key]

def get_gemini_client(config: dict[str, Any]) -> genai.Client:
    key = config["api_keys"].get("gemini") or FALLBACK_GEMINI_KEY
    if key not in _gemini_clients:
        _gemini_clients[key] = genai.Client(api_key=key)
    return _gemini_clients[key]

# â”€â”€ Background task helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def create_tracked_task(coro: Any) -> asyncio.Task:
    task = asyncio.create_task(coro)
    task.add_done_callback(_log_task_exception)
    return task

def _log_task_exception(task: asyncio.Task) -> None:
    if not task.cancelled() and task.exception():
        logger.error("Background task raised: %s", task.exception())

async def delete_later(message: Any, delay: int = 3) -> None:
    await asyncio.sleep(delay)
    try:
        await message.delete()
    except Exception as e:
        logger.debug("delete_later: %s", e)

# â”€â”€ Language detection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#
# ROOT CAUSE OF THE BUG:
#   langdetect failed on short CJK text â€” "å¤šåˆ†é¢¨" came back as "ko"
#   because the model had no hiragana/katakana to anchor on.
#
# THE FIX: Unicode script ranges first.
#   Korean Hangul, Japanese Kana, Arabic, Cyrillic, Thai and Hebrew
#   each have their OWN exclusive Unicode block. One character is
#   enough for 100% certainty. langdetect is only called for the
#   truly ambiguous cases (Latin text, or pure CJK kanji that could
#   be either Chinese or Japanese).
#
# Priority:
#   1. Hangul     â†’ ko    (unique block, zero ambiguity)
#   2. Kana       â†’ ja    (unique to Japanese)
#   3. Arabic     â†’ ar
#   4. Cyrillic   â†’ ru
#   5. Thai       â†’ th
#   6. Hebrew     â†’ he
#   7. langdetect for Latin / pure-kanji disambiguation
#   8. CJK ratio fallback (text too short for langdetect)

_LANG_ALIASES: dict[str, str] = {
    "zh-cn": "zh-CN", "zh-tw": "zh-TW", "zh": "zh-CN", "jp": "ja",
}

def _normalise(lang: str) -> str:
    return _LANG_ALIASES.get(lang.lower(), lang.lower())

def detect_language(text: str) -> str:
    # Step 1: unique-script checks (O(n) regex, no library, always correct)
    if re.search(r"[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]", text):
        return "ko"
    if re.search(r"[\u3040-\u30FF]", text):
        return "ja"
    if re.search(r"[\u0600-\u06FF]", text):
        return "ar"
    if re.search(r"[\u0400-\u04FF]", text):
        return "ru"
    if re.search(r"[\u0E00-\u0E7F]", text):
        return "th"
    if re.search(r"[\u0590-\u05FF]", text):
        return "he"
    # Step 2: langdetect for Latin / CJK disambiguation
    try:
        return _normalise(langdetect_detect(text))
    except LangDetectException:
        pass
    # Step 3: CJK ratio fallback
    cjk = len(re.findall(r"[\u4E00-\u9FFF]", text))
    if cjk / max(len(text.replace(" ", "")), 1) > 0.3:
        return "zh-CN"
    return "unknown"

def is_same_language(text: str, target_lang: str) -> bool:
    detected = detect_language(text)
    norm = _normalise(target_lang)
    if detected.startswith("zh") and norm.startswith("zh"):
        return True
    return detected == norm

def detect_swap_target(text: str, home_lang: str, foreign_lang: str) -> str:
    detected = detect_language(text)
    norm_home = _normalise(home_lang)
    if detected == norm_home or (detected.startswith("zh") and norm_home.startswith("zh")):
        return foreign_lang
    return home_lang

# â”€â”€ Pyrogram client â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app = Client("my_account", api_id=API_ID, api_hash=API_HASH)

# â”€â”€ Core translation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def _translate_with_engine(
    text: str, target_lang: str, engine: str, config: dict[str, Any],
) -> str:
    is_ja = target_lang.lower() in ("ja", "jp", "japanese")
    ja_rule = "2. ç»å¯¹ç¦æ­¢ä½¿ç”¨æ•¬ä½“ï¼ˆã§ã™/ã¾ã™ï¼‰ï¼å¿…é¡»ä½¿ç”¨å¸¸ä½“ï¼ˆã /ã§ã‚ã‚‹/ã‚¿å½¢ï¼‰ã€‚" if is_ja else ""
    ai_prompt = (
        "ä½ æ˜¯ä¸€ä¸ªç²¾é€šå¤šå›½ç½‘ç»œæ–‡åŒ–çš„ç¿»è¯‘å®˜ã€‚\n"
        f"ã€è¦æ±‚ã€‘ï¼š1. å£å»éšæ€§ã€æ¥åœ°æ°”ã€‚ {ja_rule} 3. ä¿šè¯­æ›¿æ¢ã€‚"
        " 4. ä¸¥ç¦æ‰­æ›²åŸæ„ï¼Œå¿…é¡»å‡†ç¡®ä¼ è¾¾è¯­æ°”ã€‚ 5. åªè¾“å‡ºçº¯ç¿»è¯‘ç»“æœï¼Œæ— è§£é‡Šã€‚\n"
        f"ã€ä»»åŠ¡ã€‘ï¼šå°†ä»¥ä¸‹æ–‡æœ¬ç¿»è¯‘ä¸º [{target_lang.upper()}]\n{text}"
    )
    logger.info("Translating  engine=%s  target=%s", engine, target_lang)

    if engine == "openai":
        res = await get_openai_client(config).chat.completions.create(
            model=config["models"].get("openai", "gpt-4o-mini"),
            messages=[{"role": "user", "content": ai_prompt}],
            temperature=0.8,
        )
        return res.choices[0].message.content.strip()

    if engine == "gemini":
        res = await get_gemini_client(config).aio.models.generate_content(
            model=config["models"].get("gemini", "gemini-1.5-flash"),
            contents=ai_prompt,
        )
        return res.text.strip()

    if engine == "google":
        return await asyncio.to_thread(
            lambda: GoogleTranslator(source="auto", target=target_lang).translate(text)
        )

    if engine in config["custom_engines"]:
        cfg = config["custom_engines"][engine]
        client = AsyncOpenAI(api_key=cfg["api_key"], base_url=cfg["base_url"], timeout=15.0)
        res = await client.chat.completions.create(
            model=cfg["model"],
            messages=[{"role": "user", "content": ai_prompt}],
            temperature=0.8,
        )
        return res.choices[0].message.content.strip()

    raise ValueError(f"Unknown engine: {engine!r}")

# â”€â”€ Fallback gateway â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def translate_text_with_fallback(
    text: str, target_lang: str, preferred_engine: str,
) -> str:
    config = load_config()
    seen: set[str] = set()
    engines_to_try: list[str] = []
    for e in [preferred_engine, *config.get("custom_engines", {}).keys(), "gemini", "openai", "google"]:
        if e not in seen:
            seen.add(e)
            engines_to_try.append(e)
    errors: list[str] = []
    for engine in engines_to_try:
        try:
            return await _translate_with_engine(text, target_lang, engine, config)
        except Exception as ex:
            logger.warning("Engine %s failed: %s", engine, ex)
            errors.append(f"{engine}({str(ex)[:30]})")
    return f"ERROR: å…¨éƒ¨èŠ‚ç‚¹å´©æºƒ ({' | '.join(errors[:2])}...)"

# â”€â”€ Translate + edit â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async def do_translate_and_edit(
    message: Any,
    original_text: str,
    target_langs_str: str,
    mode: str = "append",
    skip_if_target: bool = False,
) -> None:
    config = load_config()
    current_engine = config.get("engine", "gemini")
    target_langs = [l.strip() for l in target_langs_str.split(",") if l.strip()]

    # Smart skip: leave the message alone if it's already in the target language
    if skip_if_target and len(target_langs) == 1:
        if is_same_language(original_text, target_langs[0]):
            logger.debug("skip_if_target: already %s, skipping", target_langs[0])
            return

    try:
        loading = f"<blockquote>â³ ç¿»è¯‘ä¸­ ({current_engine.upper()})...</blockquote>"
        await message.edit_text(
            f"{original_text}\n{loading}" if mode == "append" else loading,
            parse_mode=ParseMode.HTML,
        )
        results = await asyncio.gather(
            *[translate_text_with_fallback(original_text, lang, current_engine) for lang in target_langs]
        )
        final_blocks: list[str] = []
        has_error = False
        for lang, result in zip(target_langs, results):
            if result.startswith("ERROR:"):
                has_error = True
                final_blocks.append(f"<blockquote>âŒ [{lang.upper()}] ç¿»è¯‘å¤±è´¥</blockquote>")
            else:
                prefix = f"<b>[{lang.upper()}]</b> " if len(target_langs) > 1 else ""
                final_blocks.append(f"<blockquote>{prefix}{result}</blockquote>")
        final_text = (
            f"{original_text}\n" + "\n".join(final_blocks)
            if mode == "append" else "\n\n".join(final_blocks)
        )
        await message.edit_text(final_text, parse_mode=ParseMode.HTML)
        if has_error:
            await asyncio.sleep(5)
            await message.edit_text(original_text)
    except Exception as e:
        logger.exception("do_translate_and_edit failed")
        await message.edit_text(f"{original_text}\n\nâš ï¸ ç³»ç»Ÿå¼‚å¸¸: {str(e)[:50]}")
        create_tracked_task(delete_later(message, 5))

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COMMAND HANDLERS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@app.on_message(filters.me & filters.text & filters.command("help", prefixes="."))
async def show_help(client: Client, message: Any) -> None:
    config = load_config()
    engine = config.get("engine", "gemini")
    home_lang = config.get("home_lang", "zh-CN")
    default_lang = config.get("default_lang", "ja")
    model_display = (
        config.get("models", {}).get(engine, "é»˜è®¤")
        if engine in ("openai", "gemini")
        else config.get("custom_engines", {}).get(engine, {}).get("model", "æœªçŸ¥")
    )
    auto = config.get("auto_cmd", "")
    auto_status = f"âœ… `.{auto}`" if auto else "âŒ å…³é—­"
    custom_list = ", ".join(config.get("custom_engines", {}).keys()) or "æ— "

    help_text = (
        "ğŸ¤– **é«˜å¯ç”¨å¤šè¯­ç¿»è¯‘ç½‘å…³ Â· å®Œæ•´æŒ‡ä»¤æ‰‹å†Œ**\n"
        f"âš™ï¸ å¼•æ“: `{engine}` Â· æ¨¡å‹: `{model_display}`\n"
        f"ğŸŒ æ¯è¯­: `{home_lang}` Â· é»˜è®¤å¤–è¯­: `{default_lang}`\n"
        f"ğŸ”„ è‡ªåŠ¨æ¨¡å¼: {auto_status}\n"
        f"ğŸ”Œ è‡ªå®šä¹‰å¼•æ“: `{custom_list}`\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸ“ **åŸºç¡€ç¿»è¯‘ Â· è¿½åŠ æ¨¡å¼**\n"
        "ç¿»è¯‘ç»“æœè¿½åŠ åœ¨åŸæ–‡ä¸‹æ–¹\n\n"
        "`.tr <æ–‡æœ¬>` â€” ç¿»è¯‘ä¸ºé»˜è®¤å¤–è¯­\n"
        "  ä¾‹: `.tr ä»Šå¤©å¤©æ°”çœŸå¥½`\n\n"
        "`.t <è¯­è¨€> <æ–‡æœ¬>` â€” ç¿»è¯‘ä¸ºæŒ‡å®šè¯­è¨€\n"
        "  ä¾‹: `.t en ä½ å¥½ä¸–ç•Œ`\n"
        "  ä¾‹: `.t ja,ko,en ä½ å¥½` â† åŒæ—¶è¯‘å¤šè¯­\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸ”„ **åŸºç¡€ç¿»è¯‘ Â· æ›¿æ¢æ¨¡å¼**\n"
        "åŸæ–‡è¢«ç¿»è¯‘ç»“æœå®Œå…¨æ›¿æ¢\n\n"
        "`.rr <æ–‡æœ¬>` â€” æ›¿æ¢ä¸ºé»˜è®¤å¤–è¯­\n"
        "  ä¾‹: `.rr ä»Šå¤©å¤©æ°”çœŸå¥½`\n\n"
        "`.r <è¯­è¨€> <æ–‡æœ¬>` â€” æ›¿æ¢ä¸ºæŒ‡å®šè¯­è¨€\n"
        "  ä¾‹: `.r ja æˆ‘å–œæ¬¢çŒ«`\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸ’¬ **ç¿»è¯‘ä»–äººæ¶ˆæ¯**\n\n"
        "`.tl` â€” ç¿»è¯‘ä½ æ­£åœ¨å›å¤çš„æ¶ˆæ¯ï¼ˆè¯‘ä¸ºæ¯è¯­ï¼‰\n"
        "  å…ˆå›å¤ä¸€æ¡æ¶ˆæ¯ï¼Œå†å‘ `.tl`\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸ¤– **è‡ªåŠ¨æ¨¡å¼**\n"
        "å¼€å¯åï¼Œæ¯æ¡å‘å‡ºçš„æ¶ˆæ¯è‡ªåŠ¨å¤„ç†ã€‚\n"
        "tr/rr æ¨¡å¼å†…ç½®æ™ºèƒ½è·³è¿‡ï¼šå¦‚æœæ¶ˆæ¯å·²æ˜¯ç›®æ ‡\n"
        "è¯­è¨€ï¼Œåˆ™è‡ªåŠ¨è·³è¿‡ï¼Œä¸åšä»»ä½•ä¿®æ”¹ã€‚\n\n"
        "`.auto swap` â€” ğŸŒŸ **æ™ºèƒ½åŒå‘äº’è¯‘** (æœ€æ¨è)\n"
        "  å‘ä¸­æ–‡ â†’ è‡ªåŠ¨è¿½åŠ å¤–è¯­ç¿»è¯‘\n"
        "  å‘æ—¥æ–‡/è‹±æ–‡ç­‰ â†’ è‡ªåŠ¨è¿½åŠ ä¸­æ–‡ç¿»è¯‘\n\n"
        "`.auto tr` â€” è¿½åŠ é»˜è®¤å¤–è¯­ (å·²æ˜¯ç›®æ ‡è¯­åˆ™è·³è¿‡)\n"
        "`.auto rr` â€” æ›¿æ¢ä¸ºé»˜è®¤å¤–è¯­ (å·²æ˜¯ç›®æ ‡è¯­åˆ™è·³è¿‡)\n"
        "`.auto t ja` â€” è¿½åŠ æ—¥è¯­ (å·²æ˜¯æ—¥è¯­åˆ™è·³è¿‡)\n"
        "`.auto r ko` â€” æ›¿æ¢ä¸ºéŸ©è¯­\n"
        "`.auto off` â€” ğŸ›‘ å…³é—­è‡ªåŠ¨æ¨¡å¼\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸ” **æ£€æµ‹ä¸è¯Šæ–­**\n\n"
        "`.detect` â€” å‡†ç¡®è¯†åˆ«è¯­è¨€\n"
        "  ä¾‹: `.detect å¤šåˆ†é¢¨` â†’ `ja` âœ…\n"
        "  æˆ–: å›å¤æ¶ˆæ¯åå‘ `.detect`\n\n"
        "`.ping` â€” æµ‹è¯•æ‰€æœ‰å¼•æ“å»¶è¿Ÿ\n"
        "`.status` â€” æŸ¥çœ‹æ‰€æœ‰å½“å‰é…ç½®\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸ“‹ **æ¶ˆæ¯å·¥å…·**\n\n"
        "`.copy` â€” å¤åˆ¶å›å¤æ¶ˆæ¯çš„åŸæ–‡\n"
        "  å…ˆå›å¤ä¸€æ¡æ¶ˆæ¯ï¼Œå†å‘ `.copy`\n\n"
        "`.len` â€” ç»Ÿè®¡å­—æ•°/å­—ç¬¦æ•°\n"
        "  ä¾‹: `.len ä½ å¥½ä¸–ç•Œ` æˆ–å›å¤åå‘ `.len`\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "âš™ï¸ **ç³»ç»Ÿé…ç½®**\n\n"
        "`.setlang <ä»£ç >` â€” è®¾ç½®é»˜è®¤å¤–è¯­\n"
        "  ä¾‹: `.setlang ko` / `.setlang en`\n\n"
        "`.sethome <ä»£ç >` â€” è®¾ç½®æ¯è¯­ (swapåˆ¤æ–­ç”¨)\n"
        "  ä¾‹: `.sethome zh-CN`\n\n"
        "`.setengine <åç§°>` â€” åˆ‡æ¢å¼•æ“\n"
        "  å¯é€‰: `gemini` / `openai` / `google` / è‡ªå®šä¹‰\n\n"
        "`.setmodel <æ¨¡å‹å>` â€” ä¿®æ”¹å½“å‰å¼•æ“æ¨¡å‹\n"
        "  ä¾‹: `.setmodel gpt-4o`\n\n"
        "`.setkey <openai/gemini> <KEY>` â€” æ›´æ–° API Key\n\n"

        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        "ğŸ”Œ **è‡ªå®šä¹‰å¼•æ“ (å…¼å®¹ OpenAI API æ ¼å¼)**\n\n"
        "`.addapi <å> <URL> <Key> <æ¨¡å‹>` â€” æ·»åŠ \n"
        "  ä¾‹: `.addapi grok https://api.x.ai/v1 xai-xxx grok-3`\n\n"
        "`.editapi <å> <URL> <Key> <æ¨¡å‹>` â€” ä¿®æ”¹\n"
        "`.delapi <å>` â€” åˆ é™¤\n"
    )
    await message.edit_text(help_text, parse_mode=ParseMode.MARKDOWN)


@app.on_message(filters.me & filters.text & filters.command("status", prefixes="."))
async def show_status(client: Client, message: Any) -> None:
    config = load_config()
    engine = config.get("engine", "gemini")
    models = config.get("models", {})
    custom_engines = config.get("custom_engines", {})
    api_keys = config.get("api_keys", {})
    def key_status(k: str) -> str:
        return "âœ… å·²è®¾ç½®" if k else "âš ï¸ æœªè®¾ç½® (ä½¿ç”¨å†…ç½®å¤‡ç”¨)"
    custom_lines = "\n".join(
        f"  â€¢ `{n}` â€” {c.get('model','?')}  ({c.get('base_url','?')[:40]})"
        for n, c in custom_engines.items()
    ) or "  (æ— )"
    await message.edit_text(
        "ğŸ“Š **å½“å‰ç³»ç»ŸçŠ¶æ€**\n\n"
        f"ğŸ”„ **å¼•æ“**: `{engine}`\n"
        f"ğŸ§  **OpenAI æ¨¡å‹**: `{models.get('openai','æœªè®¾ç½®')}`\n"
        f"ğŸ§  **Gemini æ¨¡å‹**: `{models.get('gemini','æœªè®¾ç½®')}`\n\n"
        f"ğŸŒ **æ¯è¯­**: `{config.get('home_lang','zh-CN')}`\n"
        f"ğŸŒ **é»˜è®¤å¤–è¯­**: `{config.get('default_lang','ja')}`\n\n"
        f"ğŸ¤– **è‡ªåŠ¨æ¨¡å¼**: `{'.' + config.get('auto_cmd','') if config.get('auto_cmd') else 'å…³é—­'}`\n\n"
        f"ğŸ”‘ **OpenAI Key**: {key_status(api_keys.get('openai',''))}\n"
        f"ğŸ”‘ **Gemini Key**: {key_status(api_keys.get('gemini',''))}\n\n"
        f"ğŸ”Œ **è‡ªå®šä¹‰å¼•æ“**:\n{custom_lines}",
        parse_mode=ParseMode.MARKDOWN,
    )
    create_tracked_task(delete_later(message, 15))


@app.on_message(filters.me & filters.text & filters.command("ping", prefixes="."))
async def ping_engines(client: Client, message: Any) -> None:
    config = load_config()
    await message.edit_text("ğŸ” æ­£åœ¨æµ‹è¯•æ‰€æœ‰å¼•æ“è¿æ¥...")
    all_engines = ["gemini", "openai", "google"] + list(config.get("custom_engines", {}).keys())
    lines: list[str] = []
    for engine in all_engines:
        start = time.monotonic()
        try:
            result = await _translate_with_engine("Hello", "zh-CN", engine, config)
            ms = int((time.monotonic() - start) * 1000)
            lines.append(f"âœ… `{engine}` â€” {ms}ms  (`{result[:12]}`)")
        except Exception as e:
            ms = int((te.monotonic() - start) * 1000)
            lines.append(f"âŒ `{engine}` â€” {ms}ms  ({str(e)[:35]})")
    await message.edit_text(
        "ğŸ“¡ **å¼•æ“è¿æ¥æµ‹è¯•ç»“æœ**\n\n" + "\n".join(lines),
        parse_mode=ParseMode.MARKDOWN,
    )
    create_tracked_task(delete_later(message, 20))


@app.on_message(filters.me & filters.text & filters.command("detect", prefixes="."))
async def detect_language_cmd(client: Client, message: Any) -> None:
    parts = message.text.split(maxsplit=1)
    target: str | None = (
        parts[1].strip() if len(parts) > 1
        else (message.reply_to_message.text if message.reply_to_message and message.reply_to_message.text else None)
    )
    if not target:
        await message.edit_text(
            "âŒ ç”¨æ³•: `.detect <æ–‡æœ¬>` æˆ–å›å¤æ¶ˆæ¯åå‘ `.detect`",
            parse_mode=ParseMode.MARKDOWN,
        )
        create_tracked_task(delete_later(message, 5))
        return
    detected = await asyncio.to_thread(detect_language, target)
    preview = target[:40] + ("..." if len(target) > 40 else "")
    await message.edit_text(
        f"ğŸ” **è¯­è¨€æ£€æµ‹ç»“æœ**\n\næ–‡æœ¬: `{preview}`\næ£€æµ‹è¯­è¨€: **`{detected}`**",
        parse_mode=ParseMode.MARKDOWN,
    )
    create_tracked_task(delete_later(message, 8))


@app.on_message(filters.me & filters.text & filters.command("copy", prefixes="."))
async def copy_reply(client: Client, message: Any) -> None:
    if message.reply_to_message and message.reply_to_message.text:
        await message.edit_text(message.reply_to_message.text)
    else:
        await message.edit_text("âŒ è¯·å…ˆå›å¤ä¸€æ¡æ–‡æœ¬æ¶ˆæ¯ï¼Œå†ä½¿ç”¨ `.copy`")
        create_tracked_task(delete_later(message, 5))


@app.on_message(filters.me & filters.text & filters.command("len", prefixes="."))
async def count_length(client: Client, message: Any) -> None:
    parts = message.text.split(maxsplit=1)
    target: str | None = (
        parts[1].strip() if len(parts) > 1
        else (message.reply_to_message.text if message.reply_to_message and message.reply_to_message.text else None)
    )
    if not target:
        await message.edit_text("âŒ ç”¨æ³•: `.len <æ–‡æœ¬>` æˆ–å›å¤æ¶ˆæ¯åå‘ `.len`")
        create_tracked_task(delete_later(message, 5))
        return
    await message.edit_text(
        f"ğŸ“ **å­—æ•°ç»Ÿè®¡**\n\n"
        f"æ–‡æœ¬: `{target[:30]}{'...' if len(target)>30 else ''}`\n\n"
        f"å­—ç¬¦æ•° (å«ç©ºæ ¼): **{len(target)}**\n"
        f"å­—ç¬¦æ•° (ä¸å«ç©ºæ ¼): **{len(target.replace(' ','').replace(chr(10),''))}**\n"
        f"å•è¯æ•°: **{len(target.split())}**\n"
        f"è¡Œæ•°: **{target.count(chr(10))+1}**",
        parse_mode=ParseMode.MARKDOWN,
    )
    create_tracked_task(delete_later(message, 10))


@app.on_message(filters.me & filters.text & filters.command("setkey", prefixes="."))
async def set_key(client: Client, message: Any) -> None:
    parts = message.text.split(maxsplit=2)
    if len(parts) == 3:
        engine, new_key = parts[1].strip().lower(), parts[2].strip()
        config = load_config()
        if engine in ("openai", "gemini"):
            api_keys = config.get("api_keys", {})
            api_keys[engine] = new_key
            (_openai_clients if engine == "openai" else _gemini_clients).clear()
            save_config("api_keys", api_keys)
            await message.edit_text(f"âœ… `{engine}` çš„ API Key å·²æ›´æ–°ï¼", parse_mode=ParseMode.MARKDOWN)
        else:
            await message.edit_text("âŒ åªèƒ½ä¿®æ”¹ `openai` æˆ– `gemini` çš„ Keyã€‚")
    else:
        await message.edit_text("âŒ ç”¨æ³•: `.setkey <openai/gemini> <KEY>`")
    create_tracked_task(delete_later(message))


@app.on_message(filters.me & filters.text & filters.command("auto", prefixes="."))
async def set_auto_mode(client: Client, message: Any) -> None:
    parts = message.text.split(" ", 1)
    if len(parts) == 1 or parts[1].strip().lower() in ("off", "stop"):
        save_config("auto_cmd", "")
        await message.edit_text("ğŸ›‘ è‡ªåŠ¨æ¨¡å¼å·²å…³é—­")
    else:
        save_config("auto_cmd", parts[1].strip())
        await message.edit_text(f"âœ… è‡ªåŠ¨æ¨¡å¼å·²è®¾ä¸º: `.{parts[1].strip()}`")
    create_tracked_task(delete_later(message))


@app.on_message(filters.me & filters.text & filters.command("setengine", prefixes="."))
async def set_engine(client: Client, message: Any) -> None:
    parts = message.text.split(" ", 1)
    if len(parts) > 1:
        save_config("engine", parts[1].strip().lower())
        await message.edit_text(f"ğŸš€ å¼•æ“åˆ‡æ¢è‡³: **{parts[1].strip()}**", parse_mode=ParseMode.MARKDOWN)
        create_tracked_task(delete_later(message))


@app.on_message(filters.me & filters.text & filters.command("setmodel", prefixes="."))
async def set_model(client: Client, message: Any) -> None:
    parts = message.text.split(" ", 1)
    if len(parts) > 1:
        config = load_config()
        engine = config.get("engine", "gemini")
        new_model = parts[1].strip()
        if engine in ("openai", "gemini"):
            m = config.get("models", {}); m[engine] = new_model; save_config("models", m)
        elif engine in config.get("custom_engines", {}):
            config["custom_engines"][engine]["model"] = new_model
            save_config("custom_engines", config["custom_engines"])
        await message.edit_text(f"âœ… `{engine}` æ¨¡å‹æ”¹ä¸º: **{new_model}**", parse_mode=ParseMode.MARKDOWN)
        create_tracked_task(delete_later(message))


@app.on_message(filters.me & filters.text & filters.command("setlang", prefixes="."))
async def set_lang(client: Client, message: Any) -> None:
    parts = message.text.split(" ", 1)
    if len(parts) > 1:
        save_config("default_lang", parts[1].strip())
        await message.edit_text(f"âœ… é»˜è®¤å¤–è¯­åˆ‡æ¢ä¸º: **{parts[1].strip()}**", parse_mode=ParseMode.MARKDOWN)
        create_tracked_task(delete_later(message))


@app.on_message(filters.me & filters.text & filters.command("sethome", prefixes="."))
async def set_home(client: Client, message: Any) -> None:
    parts = message.text.split(" ", 1)
    if len(parts) > 1:
        save_config("home_lang", parts[1].strip())
        await message.edit_text(
            f"âœ… æ¯è¯­è®¾ç½®ä¸º: **{parts[1].strip()}**\nSwap æ¨¡å¼å°†ä»¥æ­¤åˆ¤æ–­ç¿»è¯‘æ–¹å‘ã€‚",
            parse_mode=ParseMode.MARKDOWN,
        )
        create_tracked_task(delete_later(message))
    else:
        await message.edit_text("âŒ ç”¨æ³•: `.sethome zh-CN`")
        create_tracked_task(delete_later(message, 5))


@app.on_message(filters.me & filters.text & filters.command("addapi", prefixes="."))
async def add_api(client: Client, message: Any) -> None:
    parts = message.text.split(maxsplit=4)
    if len(parts) == 5:
        _, name, url, key, model = parts
        config = load_config()
        config["custom_engines"][name.lower()] = {"base_url": url, "api_key": key, "model": model}
        save_config("custom_engines", config["custom_engines"])
        await message.edit_text(f"âœ… æ·»åŠ å¼•æ“: `{name}`", parse_mode=ParseMode.MARKDOWN)
    else:
        await message.edit_text("âŒ ç”¨æ³•: `.addapi <åç§°> <base_url> <api_key> <model>`")
    create_tracked_task(delete_later(message))


@app.on_message(filters.me & filters.text & filters.command("editapi", prefixes="."))
async def edit_api(client: Client, message: Any) -> None:
    parts = message.text.split(maxsplit=4)
    if len(parts) == 5:
        _, name, url, key, model = parts
        config = load_config()
        config["custom_engines"][name.lower()] = {"base_url": url, "api_key": key, "model": model}
        save_config("custom_engines", config["custom_engines"])
        await message.edit_text(f"âœ… ä¿®æ”¹å¼•æ“: `{name}`", parse_mode=ParseMode.MARKDOWN)
    create_tracked_task(delete_later(message))


@app.on_message(filters.me & filters.text & filters.command("delapi", prefixes="."))
async def del_api(client: Client, message: Any) -> None:
    parts = message.text.split(" ", 1)
    if len(parts) > 1:
        name = parts[1].strip().lower()
        config = load_config()
        if name in config["custom_engines"]:
            del config["custom_engines"][name]
            save_config("custom_engines", config["custom_engines"])
            if config.get("engine") == name:
                save_config("engine", "gemini")
            await message.edit_text(f"ğŸ—‘ åˆ é™¤å¼•æ“: `{name}`", parse_mode=ParseMode.MARKDOWN)
        else:
            await message.edit_text(f"âŒ å¼•æ“ `{name}` ä¸å­˜åœ¨")
    create_tracked_task(delete_later(message))

# â”€â”€ Shortcut commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@app.on_message(filters.me & filters.text & filters.regex(r"^\.tl$"))
async def translate_reply(client: Client, message: Any) -> None:
    config = load_config()
    if message.reply_to_message and message.reply_to_message.text:
        await do_translate_and_edit(
            message, message.reply_to_message.text,
            config.get("home_lang", "zh-CN"), mode="replace"
        )

@app.on_message(filters.me & filters.text & filters.regex(r"^\.tr\s+([\s\S]+)"))
async def cmd_tr(client: Client, message: Any) -> None:
    config = load_config()
    await do_translate_and_edit(message, message.matches[0].group(1), config["default_lang"], mode="append")

@app.on_message(filters.me & filters.text & filters.regex(r"^\.t\s+([a-zA-Z\-,]+)\s+([\s\S]+)"))
async def cmd_t(client: Client, message: Any) -> None:
    await do_translate_and_edit(message, message.matches[0].group(2), message.matches[0].group(1), mode="append")

@app.on_message(filters.me & filters.text & filters.regex(r"^\.rr\s+([\s\S]+)"))
async def cmd_rr(client: Client, message: Any) -> None:
    config = load_config()
    await do_translate_and_edit(message, message.matches[0].group(1), config["default_lang"], mode="replace")

@app.on_message(filters.me & filters.text & filters.regex(r"^\.r\s+([a-zA-Z\-,]+)\s+([\s\S]+)"))
async def cmd_r(client: Client, message: Any) -> None:
    await do_translate_and_edit(message, message.matches[0].group(2), message.matches[0].group(1), mode="replace")

# â”€â”€ Auto translate interceptor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@app.on_message(filters.me & filters.text & ~filters.regex(r"^\."))
async def auto_translate_handler(client: Client, message: Any) -> None:
    config = load_config()
    auto_cmd = config.get("auto_cmd", "")
    if not auto_cmd:
        return
    text = message.text
    parts = auto_cmd.split(" ", 1)
    cmd = parts[0]

    if cmd == "swap":
        target_lang = detect_swap_target(
            text, config.get("home_lang", "zh-CN"), config.get("default_lang", "ja")
        )
        await do_translate_and_edit(message, text, target_lang, mode="append")
    elif cmd == "tr":
        await do_translate_and_edit(message, text, config["default_lang"], mode="append", skip_if_target=True)
    elif cmd == "rr":
        await do_translate_and_edit(message, text, config["default_lang"], mode="replace", skip_if_target=True)
    elif cmd == "t" and len(parts) > 1:
        await do_translate_and_edit(message, text, parts[1], mode="append", skip_if_target=True)
    elif cmd == "r" and len(parts) > 1:
        await do_translate_and_edit(message, text, parts[1], mode="replace", skip_if_target=True)

# â”€â”€ Entrypoint â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if __name__ == "__main__":
    logger.info("ğŸš€ Translation bot starting...")
    logger.info("ğŸ›¡ï¸  Auto-fallback gateway standing by...")
    app.run()
